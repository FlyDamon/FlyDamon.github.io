<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2019%2F01%2F19%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3 选择器（Selector）过 CSS 的人应该对 CSS 选择器不陌生，我们所定义的 CSS 属性之所以能应用到相应的节点上，就是因为 CSS 选择器模式。参考下述代码：清单 1. CSS 选择器案例 12345Body &gt; .mainTabContainer div &gt; span[5]&#123; Border: 1px solod red; Background-color: white; Cursor: pointer; &#125; 此处的 CSS 选择器即：“body &gt; .mainTabContainer div span[5]” 代表这这样一条路径： “body”标签直接子元素里 class 属性值为“mainTabContainer”的所有元素 A A 的后代元素（descendant）里标签为 div 的所有元素 B B 的直接子元素中的第 5 个标签为 span 的元素 C 这个 C 元素（可能为多个）即为选择器定位到的元素，如上的 CSS 属性也会全部应用到 C 元素上。 以上为 CSS2 及之前版本所提供的主要定位方式。现在，CSS3 提供了更多更加方便快捷的选择器： 清单 2. CSS3 选择器案例 123456789101112131415Body &gt; .mainTabContainer tbody:nth-child(even)&#123; Background-color: white; &#125; Body &gt; .mainTabContainer tr:nth-child(odd)&#123; Background-color: black; &#125; :not(.textinput)&#123; Font-size: 12px; &#125; Div:first-child&#123; Border-color: red; &#125; 如上所示，我们列举了一些 CSS3 的选择器，在我们日常的开发中可能会经常用到，这些新的 CSS3 特性解决了很多我们之前需要用 JavaScript 脚本才能解决的问题。tbody: nth-child(even), nth-child(odd)：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr），这种样式非常适用于表格，让人能非常清楚的看到表格的行与行之间的差别，让用户易于浏览。: not(.textinput)：这里即表示所有 class 不是“textinput”的节点。div:first-child：这里表示所有 div 节点下面的第一个直接子节点。除此之外，还有很多新添加的选择器： 12345678910111213E:nth-last-child(n) E:nth-of-type(n) E:nth-last-of-type(n) E:last-child E:first-of-type E:only-child E:only-of-type E:empty E:checked E:enabled E:disabled E::selection E:not(s) 这里不一一介绍。学会利用这些新特性可以极大程度的减少我们的无畏代码，并且大幅度的提高程序的性能。 @Font-face 特性Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。先来看一个客户端字体简单的案例：清单 3. Font-face 客户端字体案例 1&lt;p&gt;&lt;font face=&quot;arial&quot;&gt;arial courier verdana&lt;/font&gt;&lt;/p&gt; 我们可以通过这种方式直接加载字体样式，因为这些字体（arial）已经安装在客户端了。清单 3 这种写法的作用等同于清单 4：清单 4. 字体基本写法 1&lt;p&gt;&lt;font style=&quot;font-family: arial&quot;&gt;arial courier verdana&lt;/font&gt;&lt;/p&gt; 相信这种写法大家应该再熟悉不过了。接下来我们看看如何使用服务端字体，即：未在客户端安装的字体样式。参看如下代码：清单 5. Font-face 服务端字体案例 1234567891011@font-face &#123; font-family: BorderWeb; src:url(BORDERW0.eot); &#125; @font-face &#123; font-family: Runic; src:url(RUNICMT0.eot); &#125; .border &#123; FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: &quot;BorderWeb&quot; &#125; .event &#123; FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: &quot;Runic&quot; &#125; 清单 5 中声明的两个服务端字体，其字体源指向“BORDERW0.eot”和“RUNICMT0.eot”文件，并分别冠以“BorderWeb”和“Runic”的字体名称。声明之后，我们就可以在页面中使用了：“ FONT-FAMILY: “BorderWeb” ” 和 “ FONT-FAMILY: “Runic” ”。 这种做法使得我们在开发中如果需要使用一些特殊字体，而又不确定客户端是否已安装时，便可以使用这种方式。 Word-wrap &amp; Text-overflow 样式Word-wrap先来看看 word-wrap 属性，参考下述代码：清单 6. word-wrap 案例 12345678&lt;div style=&quot;width:300px; border:1px solid #999999; overflow: hidden&quot;&gt; wordwrapbreakwordwordwrapbreakwordwordwrapbreakwordwordwrapbreakword &lt;/div&gt; &lt;div style=&quot;width:300px; border:1px solid #999999; word-wrap:break-word;&quot;&gt; wordwrapbreakwordwordwrapbreakwordwordwrapbreakwordwordwrapbreakword &lt;/div&gt; 比较上述两段代码，加入了“word-wrap: break-word”，设置或检索当当前行超过指定容器的边界时是否断开转行，文字此时已被打散。所以可见如下的差别：图 1. 没有 break-word图 2. 有 break-word Text-overflow知道了 word-wrap 的原理，我们再来看看 text-overflow，其实它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示，见如下示例： 清单 7. Text-overflow 案例 12345678910111213141516.clip&#123; text-overflow:clip; overflow:hidden; white-space:nowrap; width:200px;background:#ccc;&#125; .ellipsis&#123; text-overflow:ellipsis; overflow:hidden; white-space:nowrap; width:200px; background:#ccc;&#125; &lt;div class=&quot;clip&quot;&gt; 不显示省略标记，而是简单的裁切条&lt;/div&gt; &lt;div class=&quot;ellipsis&quot;&gt; 当对象内文本溢出时显示省略标记&lt;/div&gt; 如清单 7 所示，这里我们均使用“overflow: hidden”，对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。见图 3 的效果图。图 3. Text-overflow 效果图这里我们可以看到，ellipsis 的显示方式比较人性化，clip 方式比较传统，我们可以依据需求进行选择。 文字渲染（Text-decoration）CSS3 里面开始支持对文字的更深层次的渲染，我们来看看下面的例子：清单 8. Text-decoration 案例 12345div &#123; -webkit-text-fill-color: black; -webkit-text-stroke-color: red; -webkit-text-stroke-width: 2.75px; &#125; 这里我们主要以 webkit 内核浏览器为例，清单 8 的代码效果如图 4：图 4. Text-decoration 效果图Text-fill-color: 文字内部填充颜色Text-stroke-color: 文字边界填充颜色Text-stroke-width: 文字边界宽度 CSS3 的多列布局（multi-column layout）CSS3 现在已经可以做简单的布局处理了，这个 CSS3 新特性又一次的减少了我们的 JavaScript 代码量，参考如下代码：清单 9. CSS3 多列布局 12345678910.multi_column_style&#123; -webkit-column-count: 3; -webkit-column-rule: 1px solid #bbb; -webkit-column-gap: 2em; &#125; &lt;div class=&quot;multi_column_style&quot;&gt; ................. ................. &lt;/div&gt; 这里我们还是以 webkit 内核浏览器为例：Column-count：表示布局几列。Column-rule：表示列与列之间的间隔条的样式Column-gap：表示列于列之间的间隔清单 9 的代码效果图如图 5：图 5. 多列布局效果图 边框和颜色（color, border）关于颜色，CSS3 已经提供透明度的支持了：清单 10. 颜色的透明度 12color: rgba(255, 0, 0, 0.75); background: rgba(0, 0, 255, 0.75); 这里的“rgba”属性中的“a”代表透明度，也就是这里的“0.75”，同时 CSS3 还支持 HSL 颜色声明方式及其透明度：清单 11. HSL 的透明度 1color: hsla( 112, 72%, 33%, 0.68); 对于 border，CSS3 提供了圆角的支持：清单 12. 圆角案例 1border-radius: 15px; 参见下面圆角效果：Figure xxx. Requires a heading CSS3 的渐变效果（Gradient）线性渐变左上（0% 0%）到右上（0% 100%）即从左到右水平渐变：清单 13. 左到右的渐变 1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E)); 这里 linear 表示线性渐变，从左到右，由蓝色（#2A8BBE）到红色（#FE280E）的渐变。效果图如下：图 6. 简单线性渐变效果图同理，也可以有从上到下，任何颜色间的渐变转换： 图 7. 各种不同线性渐变效果图还有复杂一点的渐变，如：水平渐变，33% 处为绿色，66% 处为橙色： 清单 14. 复杂线性渐变 12background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE), color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E)); 这里的“color-stop”为拐点，可见效果图： 图 8. 复杂线性渐变效果图 径向渐变接下来我们要介绍径向渐变（radial），这不是从一个点到一个点的渐变，而从一个圆到一个圆的渐变。不是放射渐变而是径向渐变。来看一个例子：清单 15. 径向渐变（目标圆半径为 0）。 12backgroud: -webkit-gradient(radial,50 50,50,50 50,0,from(black),color-stop(0.5,red),to(blue)); 前面“50,50,50”是起始圆的圆心坐标和半径，“50,50,0”蓝色是目标圆的圆心坐标和半径，“color-stop(0.5,red)”是断点的位置和色彩。这里需要说明一下，和放射由内至外不一样，径向渐变刚好相反，是由外到内的渐变。清单 15 标识的是两个同心圆，外圆半径为 50px，内圆半径为 0，那么就是从黑色到红色再到蓝色的正圆形渐变。下面就是这段代码的效果：图 9. 径向渐变（目标圆半径为 0）效果图如果我们给目标源一个大于 0 半径，您会看到另外一个效果：清单 16. 径向渐变（目标圆半径非 0） 12backgroud: -webkit-gradient(radial,50 50,50,50 50,10,from(black),color-stop(0.5,red),to(blue)); 这里我们给目标圆半径为 10，效果图如下：图 10. 径向渐变（目标圆半径非 0）您可以看到，会有一个半径为 10 的纯蓝的圆在最中间，这就是设置目标圆半径的效果。现在我再改变一下，不再是同心圆了，内圆圆心向右 20px 偏移。清单 17. 径向渐变（目标圆圆心偏移） 12backgroud: -webkit-gradient(radial,50 50,50,70 50,10,from(black),color-stop(0.5,red),to(blue)); 这里我们给目标圆半径还是 10，但是圆心偏移为“70，50”（起始圆圆心为“50，50”）效果图如下：图 11. 径向渐变（目标圆圆心偏移）想必您明白原理了，我们可以做一个来自顶部的漫射光，类似于开了盏灯：清单 18. 径向渐变（漫射光） 1backgroud:-webkit-gradient(radial,50 50,50,50 1,0,from(black),to(white)); 其效果如下：图 12. 径向渐变（漫射光） CSS3 的阴影（Shadow）和反射（Reflect）效果首先来说说阴影效果，阴影效果既可用于普通元素，也可用于文字，参考如下代码：清单 19. 元素和文字的阴影 1234567.class1&#123; text-shadow:5px 2px 6px rgba(64, 64, 64, 0.5); &#125; .class2&#123; box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); &#125; 设置很简单，对于文字阴影：表示 X 轴方向阴影向右 5px,Y 轴方向阴影向下 2px, 而阴影模糊半径 6px，颜色为 rgba(64, 64, 64, 0.5)。其中偏移量可以为负值，负值则反方向。元素阴影也类似。参考一下效果图：图 13. 元素和文字的阴影效果图接下来我们再来谈谈反射，他看起来像水中的倒影，其设置也很简单，参考如下代码：清单 20. 反射 12345.classReflect&#123; -webkit-box-reflect: below 10px; -webkit-gradient(linear, left top, left bottom, from(transparent), to(rgba(255, 255, 255, 0.51))); &#125; 设置也很简单，大家主要关注“-webkit-box-reflect: below 10px”，他表示反射在元素下方 10px 的地方，再配上渐变效果，可见效果图如下：图 14. 反射效果图 CSS3 的背景效果CSS3 多出了几种关于背景（background）的属性，我们这里会简单介绍一下： 首先：“Background Clip”，该属确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从 border 开始显示 ; background-clip: padding-box; 背景从 padding 开始显示 ; background-clip: content-box; 背景显 content 区域开始显示 ; background-clip: no-clip; 默认属性，等同于 border-box; 通常情况，我们的背景都是覆盖整个元素的，现在 CSS3 让您可以设置是否一定要这样做。这里您可以设定背景颜色或图片的覆盖范围。 其次：“Background Origin”，用于确定背景的位置，它通常与 background-position 联合使用，您可以从 border、padding、content 来计算 background-position（就像 background-clip）。 background-origin: border-box; 从 border. 开始计算 background-position; background-origin: padding-box; 从 padding. 开始计算 background-position; background-origin: content-box; 从 content. 开始计算 background-position; 还有，“Background Size”，常用来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 . background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 . 最后，“Background Break”属性，CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元 素没有分成多个盒子，依然是一个整体一 样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景。 这种属性让您可以设定复杂元素的背景属性。 最为重要的一点，CSS3 中支持多背景图片，参考如下代码： 清单 21. 多背景图片 1234div &#123; background: url(src/zippy-plus.png) 10px center no-repeat, url(src/gray_lines_bg.png) 10px center repeat-x; &#125; 此为同一元素两个背景的案例，其中一个重复显示，一个不重复。参考一下效果图：图 15. 多背景图片 CSS3 的盒子模型盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox。下面我们来介绍一下他是如何工作的，参考如下代码：清单 22. CSS3 盒子模型 1234567891011121314&lt;div class=&quot;boxcontainer&quot;&gt; &lt;div class=&quot;item&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;item flex&quot;&gt; 4 &lt;/div&gt; &lt;/div&gt; 默认情况下，如果“boxcontainer”和“item”两个 class 里面没有特殊属性的话，由于 div 是块状元素，所以他的排列应该是这样的：图 16. CSS3 盒子模型效果图下面，我们加入相关 CSS3 盒子模型属性：清单 23. CSS3 盒子模型（水平排列） 12345678910111213141516.boxcontainer &#123; width: 1000px; display: -webkit-box; display: -moz-box; -webkit-box-orient: horizontal; -moz-box-orient: horizontal; &#125; .item &#123; background: #357c96; font-weight: bold; margin: 2px; padding: 20px; color: #fff; font-family: Arial, sans-serif; &#125; 注意这里的“display: -webkit-box; display: -moz-box;”，它针对 webkit 和 gecko 浏览器定义了该元素的盒子模型。注意这里的“-webkit-box-orient: horizontal;”，他表示水平排列的盒子模型。此时，我们会看到如下效果：图 17. CSS3 盒子模型（水平排列）效果图细心的读者会看到，“盒子”的右侧多出来了很大一块，这是怎么回事呢？让我们再来看一个比较有特点的属性：“flex”， 参考如下代码：清单 24. CSS3 盒子模型（flex） 12345678910111213141516171819&lt;div class=&quot;boxcontainer&quot;&gt; &lt;div class=&quot;item&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;item flex&quot;&gt; 4 &lt;/div&gt; &lt;/div&gt; .flex &#123; -webkit-box-flex: 1; -moz-box-flex: 1; &#125; 您看到什么区别了没？在第四个“item 元素”那里多了一个“flex”属性，直接来看看效果吧：图 18. CSS3 盒子模型（flex）效果图第四个“item 元素”填满了整个区域，这就是“flex”属性的作用。如果我们调整一下“box-flex”的属性值，并加入更多的元素，见如下代码：清单 25. CSS3 盒子模型（flex 进阶） 123456789101112131415161718192021222324&lt;div class=&quot;boxcontainer&quot;&gt; &lt;div class=&quot;item&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;item flex2&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;item flex&quot;&gt; 4 &lt;/div&gt; &lt;/div&gt; .flex &#123; -webkit-box-flex: 1; -moz-box-flex: 1; &#125; .flex2 &#123; -webkit-box-flex: 2; -moz-box-flex: 2; &#125; 由此可见，元素 3 和元素 4 按比例“2:1”的方式填充外层“容器”的余下区域，这就是“box-flex”属性的进阶应用。还有，“box-direction”可以用来翻转这四个盒子的排序，“box-ordinal-group”可以用来改变每个盒子的位置：一个盒子的 box-ordinal-group 属性值越高，就排在越后面。盒子的对方方式可以用“box-align”和“box-pack”来设定。 CSS3 的 Transitions, Transforms 和 AnimationTransitions先说说 Transition，Transition 有下面些具体属性： transition-property：用于指定过渡的性质，比如 transition-property:backgrond 就是指 backgound 参与这个过渡 transition-duration：用于指定这个过渡的持续时间 transition-delay：用于制定延迟过渡的时间 transition-timing-function：用于指定过渡类型，有 ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier 可能您觉得摸不着头脑，其实很简单，我们用一个例子说明，参看一下如下代码： 清单 26. CSS3 的 Transition 123456789101112&lt;div id=&quot;transDiv&quot; class=&quot;transStart&quot;&gt; transition &lt;/div&gt; .transStart &#123; background-color: white; -webkit-transition: background-color 0.3s linear; -moz-transition: background-color 0.3s linear; -o-transition: background-color 0.3s linear; transition: background-color 0.3s linear; &#125; .transEnd &#123; background-color: red; &#125; 这里他说明的是，这里 id 为“transDiv”的 div，当它的初始“background-color”属性变化时（被 JavaScript 修改），会呈现出一种变化效果，持续时间为 0.3 秒，效果为均匀变换（linear）。如：该 div 的 class 属性由“transStart”改为“transEnd”，其背景会由白（white）渐变到红（red）。 Transform再来看看 Transform，其实就是指拉伸，压缩，旋转，偏移等等一些图形学里面的基本变换。见如下代码：清单 27. CSS3 的 Transform 12345678910111213141516171819.skew &#123; -webkit-transform: skew(50deg); &#125; .scale &#123; -webkit-transform: scale(2, 0.5); &#125; .rotate &#123; -webkit-transform: rotate(30deg); &#125; .translate &#123; -webkit-transform: translate(50px, 50px); &#125; .all_in_one_transform &#123; -webkit-transform: skew(20deg) scale(1.1, 1.1) rotate(40deg) translate(10px, 15px); &#125; “skew”是倾斜，“scale”是缩放，“rotate”是旋转，“translate”是平移。最后需要说明一点，transform 支持综合变换。可见其效果图如下：图 20. CSS3 的 Transform 效果图现在您应该明白 Transform 的作用了吧。结合我们之前谈到的 Transition，将它们两者结合起来，会产生类似旋转，缩放等等的效果，绝对能令人耳目一新。 Animation最后，我们来说说 Animation 吧。它可以说开辟了 CSS 的新纪元，让 CSS 脱离了“静止”这一约定俗成的前提。以 webkit 为例，见如下代码：清单 28. CSS3 的 Animation 1234567891011121314151617@-webkit-keyframes anim1 &#123; 0% &#123; Opacity: 0; Font-size: 12px; &#125; 100% &#123; Opacity: 1; Font-size: 24px; &#125; &#125; .anim1Div &#123; -webkit-animation-name: anim1 ; -webkit-animation-duration: 1.5s; -webkit-animation-iteration-count: 4; -webkit-animation-direction: alternate; -webkit-animation-timing-function: ease-in-out; &#125; 首先，定义动画的内容，如清单 28 所示，定义动画“anim1”，变化方式为由“透明”（opacity: 0）变到“不透明”（opacity: 1），同时，内部字体大小由“12px”变到“24px”。然后，再来定义 animation 的变化参数，其中，“duration”表示动画持续时间，“iteration-count”表示动画重复次数，direction 表示动画执行完一次后方向的变化方式（如第一次从右向左，第二次则从左向右），最后，“timing-function”表示变化的模式。 其实，CSS3 动画几乎支持所有的 style 变化，可以定义各种各样的动画效果以满足我们用户体验的需要。 这里，我们介绍了 CSS3 的主要的新特性，这些特性在 Chrome 和 Safari 中基本都是支持的，Firefox 支持其中的一部分，IE 和 Opera 支持的较少。读者们可以根据集体情况有选择的使用。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2019%2F01%2F18%2FHTML5%2F</url>
    <content type="text"><![CDATA[(1)语义标签语义化标签使得页面的内容结构化，见名知义| 标签 | 描述 ||–|–|| header | 定义了文档的头部区域 || footer | 定义了文档的尾部区域 || nav | 定义文档的导航 || section | 定义文档中的节（section、区段）|| article | 定义页面独立的内容区域 || aside | 定义页面的侧边栏内容 || detailes | 用于描述文档或文档某个部分的细节 || summary | 标签包含 details 元素的标题 || dialog | 定义对话框，比如提示框 | (2)增强型表单HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。| 输入类型 | 描述 ||–|–|| color | 主要用于选取颜色 || date | 从一个日期选择器选择一个日期 || datetime | 选择一个日期（UTC 时间）|| datetime-local | 选择一个日期和时间 (无时区) || email | 包含 e-mail 地址的输入域 || month | 选择一个月份 || number | 数值的输入域 || range | 一定范围内数字值的输入域 || search | 用于搜索域 || tel | 定义输入电话号码字段 || time | 选择一个时间 || url | URL 地址的输入域 || week | 选择周和年 | HTML5 也新增以下表单元素| 表单元素 | 描述 ||–|–|| datalist | 元素规定输入域的选项列表，使用 input 元素的 list 属性与 datalist 元素的 id 绑定 || keygen | 提供一种验证用户的可靠方法，标签规定用于表单的密钥对生成器字段 || output | 用于不同类型的输出，比如计算或脚本输出 | HTML5 新增的表单属性 placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。 required 属性，是一个 boolean 属性。要求填写的输入域不能为空。 pattern 属性，描述了一个正则表达式用于验证 input 元素的值。 min 和 max 属性，设置元素最小值与最大值。 step 属性，为输入域规定合法的数字间隔。 height 和 width 属性，用于 image 类型的 input 标签的图像高度和宽度。 autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。 multiple 属性 ，是一个 boolean 属性。规定 input 元素中可选择多个值。 (3)视频和音频 HTML5 提供了播放音频文件的标准，即使用 audio 元素 12345&lt;audio controls&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;您的浏览器不支持 audio 元素。&lt;/audio&gt; control 属性供添加播放、暂停和音量控件。在audio标签之间你需要插入浏览器不支持的 audio 元素的提示文本 。audio 元素允许使用多个 source 元素. source 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件目前, audio 元素支持三种音频格式文件: MP3, Wav, 和 Ogg。 HTML5 规定了一种通过 video 元素来包含视频的标准方法。 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; control 提供了 播放、暂停和音量控件来控制视频。也可以使用dom操作来控制视频的播放暂停，如 play() 和 pause() 方法。同时 video 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。与 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。video 元素支持多个source 元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式（ MP4, WebM, 和 Ogg）。 (4)Canvas绘图 Canvas - 图形 创建一个画布，一个画布在网页中是一个矩形框，通过 canvas 元素来绘制。默认情况下 元素没有边框和内容。 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt; 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小，使用 style 属性来添加边框。你可以在HTML页面中使用多个 canvas 元素。 使用Javascript来绘制图像，canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成。 123456&lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle=&quot;#FF0000&quot;; ctx.fillRect(0,0,150,75);&lt;/script&gt; getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。设置 fillStyle 属性可以是CSS颜色，渐变，或图案。fillStyle默认设置是#000000（黑色）。fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 Canvas - 路径 在Canvas上画线，我们将使用以下两种方法：moveTo(x,y) 定义线条开始坐标。lineTo(x,y) 定义线条结束坐标。绘制线条我们必须使用到 “ink” 的方法，就像stroke()。 1234567&lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(200,100); ctx.stroke();&lt;/script&gt; 定义开始坐标(0,0), 和结束坐标 (200,100). 然后使用 stroke() 方法来绘制线条。 Canvas - 文本 使用 canvas 绘制文本，重要的属性和方法如下：font - 定义字体。fillText(text,x,y) - 在 canvas 上绘制实心的文本。strokeText(text,x,y) - 在 canvas 上绘制空心的文本。使用 fillText(): 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.font=&quot;30px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,10,50); 使用 “Arial” 字体在画布上绘制一个高 30px 的文字（实心）。 Canvas - 渐变 渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。以下有两种不同的方式来设置Canvas渐变：createLinearGradient(x,y,x1,y1) - 创建线条渐变。createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。 1234567891011var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;); // Create gradientvar grd=ctx.createLinearGradient(0,0,200,0);grd.addColorStop(0,&quot;red&quot;);grd.addColorStop(1,&quot;white&quot;); // Fill with gradientctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 创建了一个线性渐变，使用渐变填充矩形。 Canvas - 图像 把一幅图像放置到画布上, 使用 drawImage(image,x,y) 方法。 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;scream&quot;);ctx.drawImage(img,10,10); 把一幅图像放置到了画布上。 (5)SVG绘图SVG 与 Canvas两者间的区别：SVG是指可伸缩的矢量图形，是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 (6)地理定位HTML5 Geolocation（地理定位）用于定位用户的位置。 12345window.navigator.geolocation &#123; getCurrentPosition: fn 用于获取当前的位置数据 watchPosition: fn 监视用户位置的改变 clearWatch: fn 清除定位监视&#125; 获取用户定位信息： 1234567891011121314151617navigator.geolocation.getCurrentPosition( function(pos)&#123; console.log(&apos;用户定位数据获取成功&apos;) //console.log(arguments); console.log(&apos;定位时间：&apos;,pos.timestamp) console.log(&apos;经度：&apos;,pos.coords.longitude) console.log(&apos;纬度：&apos;,pos.coords.latitude) console.log(&apos;海拔：&apos;,pos.coords.altitude) console.log(&apos;速度：&apos;,pos.coords.speed)&#125;, //定位成功的回调function(err)&#123; console.log(&apos;用户定位数据获取失败&apos;) //console.log(arguments);&#125; //定位失败的回调) (7)拖放API拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。拖放的源对象(可能发生移动的)可以触发的事件——3个：dragstart：拖动开始drag：拖动中dragend：拖动结束整个拖动过程的组成： dragstart1 + dragn + dragend1拖放的目标对象(不会发生移动)可以触发的事件——4个：dragenter：拖动着进入dragover：拖动着悬停dragleave：拖动着离开drop：释放整个拖动过程的组成1： dragenter1 + dragovern + dragleave1整个拖动过程的组成2： dragenter1 + dragovern + drop*1 dataTransfer：用于数据传递的“拖拉机”对象； 在拖动源对象事件中使用e.dataTransfer属性保存数据：e.dataTransfer.setData( k, v ) 在拖动目标对象事件中使用e.dataTransfer属性读取数据：var value = e.dataTransfer.getData( k ) (8)Web Worker当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。首先检测浏览器是否支持 Web Worker. 123456if(typeof(Worker)!==&quot;undefined&quot;)&#123; // 是的! Web worker 支持! // 一些代码..... &#125;else&#123; // //抱歉! Web Worker 不支持 &#125; 下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码 1234if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; 然后我们就可以从 web worker 发送和接收消息了。向 web worker 添加一个 “onmessage” 事件监听器： 123w.onmessage=function(event)&#123;document.getElementById(&quot;result&quot;).innerHTML=event.data;&#125;; 当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。如需终止 web worker，并释放浏览器/计算机资源，使用 terminate() 方法。 完整的 Web Worker 实例代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt; &lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;script&gt;var w;function startWorker()&#123;if(typeof(Worker)!==&quot;undefined&quot;)&#123; if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;;&#125;else&#123;document.getElementById(&quot;result&quot;).innerHTML=&quot;Sorry, your browser does not support Web Workers...&quot;;&#125;&#125;function stopWorker()&#123; w.terminate();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建的计数脚本，该脚本存储于 “demo_workers.js” 文件中。 12345678910var i=0; function timedCount() &#123; i=i+1; postMessage(i); setTimeout(&quot;timedCount()&quot;,500); &#125; timedCount(); (9)Web Storage使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。 客户端存储数据的两个对象为： localStorage - 没有时间限制的数据存储。 sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。 在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage： 123456789if(typeof(Storage)!==&quot;undefined&quot;) &#123; // 是的! 支持 localStorage sessionStorage 对象! // 一些代码..... &#125; else &#123; // 抱歉! 不支持 web 存储。 &#125; 不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); (10)WebSocketWebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端书籍推荐]]></title>
    <url>%2F2019%2F01%2F15%2Fweb-book%2F</url>
    <content type="text"><![CDATA[JavaScript《JavaScript高级程序设计》入门级 推荐语： 详尽地解读了JS这门语言的各个组成部分，透彻地剖析了JS所涉及的编程思想，深入浅出地演示了丰富的JS应用实例…读完这本书你不一定就能成为前端大牛，但如果你真的能把这本书读懂，吃透，那么你离JS高手肯定不远啦！ 《编写可维护的JavaScript》入门级 推荐语： 乌龟书，很薄，但从工程实践的角度谈了常见的坑，其中的工作习惯值得coder们学习 《Javascript语言精粹》 蝴蝶书 推荐语： 集 JS 之精华，弃其糟粕，人手一本，前端必备 《锋利的jQuery》 入门级 推荐语： 前后台通用快速使用jQuery，必备良书。 《JavaScript DOM 编程艺术（第二版）》入门级 推荐语： 这本书的讲解方式非常亲切，人情味十足，初学者的福音。看完也能看看蝴蝶书。 《学习 JavaScript 数据结构与算法》入门级 推荐语： 很薄的一本书，很详细的讲解了使用js实现常用的数据结构和算法，对于更高效的使用js很有帮助。 《JavaScript 权威指南》 进阶级 推荐语： 这本书，我是十分推荐新手用作进阶阅读的。对于 JavaScript 新手入门来说，其实看什么书不重要，重要的是要能引起你兴趣使得你愿意动动手做做项目。在动手做过几个项目，对了 JavaScript 有了感性认识之后，你可能就会想要学习一些进阶内容，这时候《JavaScript 权威指南》就会成为最佳的选择。Ta的价值就在于，给予你工具的同时也通过示例告诉你什么情况下应该如何使用工具。 《JavaScript忍者秘籍》 进阶级 推荐语： 这本书是jQuery库创始人编写的一本深入剖析JavaScript语言的书 对JavaScript语言的重要部分（函数、闭包和原型）进行深入、全面的介绍，以及讲述跨浏览器代码如何编写 《高性能 JavaScript》进阶级 推荐语： 各种手段优化javascript 《ECMAScript 6 标准入门》进阶级 推荐语： 刘传宗：ES6让JavaScript如虎添翼，编程体验更佳，阮一峰前辈的力作 《Build Your Own AngularJS》进阶级 推荐语： 手把手教你撸出个angularjs框架，详细剖析原理和实现 《Effective JavaScript:编写高质量JavaScript代码的68个有效方法》进阶级 推荐语： 细说了编程中容易忽略的细枝末节！ 《你不知道的 JavaScript（上）》 进阶级 推荐语： 肯定没入门级的书让你成长的那么快，但是两本书（上册+下册）能让你更深入的理解 JS 机制，对项目有个良好的把控，推荐入门后的人看。详细的讲述了this，作用域，闭包，原型链等等，把js中比较难理解的部分用例子和通俗的语言讲解出来。 《单页Web应用：JavaScript 从前端到后端》进阶级 推荐语： 通过这本书的指引了解前后端如何一起构建一个单页应用，对前端来说，也能了解一些前端以外的东西 HTML5 &amp; CSS 《HTML5 与 CSS3 基础教程（第八版）》入门级 推荐语： 就是这本书把我带入前端的，非常适合初学前端的人看，浅显易懂，有配套代码！ 《深入浅出 HTML 与 CSS》入门级 推荐语： 纯小白的我第一次买的。懂了挺多。 《CSS揭秘》进阶级 推荐语： 这本书讲了很多CSS的技巧，看完之后你会拍着脑袋说原来CSS还有这么多你不知道的东西。 《HTML5 权威指南》进阶级推荐语： 系统、全面，没有高深的用法，比较简单，如果对应用要求一般，这本书的知识完全能够应付过来，辅佐以js语言精粹，完全足够 《CSS 权威指南》进阶级 推荐语： 本书适合自学过 CSS 的人但希望全面了解 CSS 的人阅读。由浅入深，全面易懂，不愧为权威指南。虽然内容有点儿老，但依然能够满足学习的需求。 综合类 《精通正则表达式》进阶级 推荐语： 全端通用技能必须get，看完后会感觉技能绝对上一个层次。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>前端书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
</search>
