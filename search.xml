<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2019%2F01%2F18%2FHTML5%2F</url>
    <content type="text"><![CDATA[(1)语义标签语义化标签使得页面的内容结构化，见名知义| 标签 | 描述 ||——–|——–|| header | 定义了文档的头部区域 || footer | 定义了文档的尾部区域 || nav | 定义文档的导航 || section | 定义文档中的节（section、区段）|| article | 定义页面独立的内容区域 || aside | 定义页面的侧边栏内容 || detailes | 用于描述文档或文档某个部分的细节 || summary | 标签包含 details 元素的标题 || dialog | 定义对话框，比如提示框 | (2)增强型表单HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。| 输入类型 | 描述 ||——–|——–|| color | 主要用于选取颜色 || date | 从一个日期选择器选择一个日期 || datetime | 选择一个日期（UTC 时间）|| datetime-local | 选择一个日期和时间 (无时区) || email | 包含 e-mail 地址的输入域 || month | 选择一个月份 || number | 数值的输入域 || range | 一定范围内数字值的输入域 || search | 用于搜索域 || tel | 定义输入电话号码字段 || time | 选择一个时间 || url | URL 地址的输入域 || week | 选择周和年 | HTML5 也新增以下表单元素| 表单元素 | 描述 ||–|–|| datalis | 元素规定输入域的选项列表，使用 input 元素的 list 属性与 datalist 元素的 id 绑定 || keygen | 提供一种验证用户的可靠方法，标签规定用于表单的密钥对生成器字段 || output | 用于不同类型的输出，比如计算或脚本输出 | HTML5 新增的表单属性 placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。 required 属性，是一个 boolean 属性。要求填写的输入域不能为空。 pattern 属性，描述了一个正则表达式用于验证 input 元素的值。 min 和 max 属性，设置元素最小值与最大值。 step 属性，为输入域规定合法的数字间隔。 height 和 width 属性，用于 image 类型的 input 标签的图像高度和宽度。 autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。 multiple 属性 ，是一个 boolean 属性。规定 input 元素中可选择多个值。 (3)视频和音频 HTML5 提供了播放音频文件的标准，即使用 audio 元素 12345&lt;audio controls&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;您的浏览器不支持 audio 元素。&lt;/audio&gt; control 属性供添加播放、暂停和音量控件。在audio标签之间你需要插入浏览器不支持的 audio 元素的提示文本 。audio 元素允许使用多个 source 元素. source 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件目前, audio 元素支持三种音频格式文件: MP3, Wav, 和 Ogg。 HTML5 规定了一种通过 video 元素来包含视频的标准方法。 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; control 提供了 播放、暂停和音量控件来控制视频。也可以使用dom操作来控制视频的播放暂停，如 play() 和 pause() 方法。同时 video 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。与 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。video 元素支持多个source 元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式（ MP4, WebM, 和 Ogg）。 (4)Canvas绘图 Canvas - 图形 创建一个画布，一个画布在网页中是一个矩形框，通过 canvas 元素来绘制。默认情况下 元素没有边框和内容。 1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt; 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小，使用 style 属性来添加边框。你可以在HTML页面中使用多个 canvas 元素。 使用Javascript来绘制图像，canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成。 123456&lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle=&quot;#FF0000&quot;; ctx.fillRect(0,0,150,75);&lt;/script&gt; getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。设置 fillStyle 属性可以是CSS颜色，渐变，或图案。fillStyle默认设置是#000000（黑色）。fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 Canvas - 路径 在Canvas上画线，我们将使用以下两种方法：moveTo(x,y) 定义线条开始坐标。lineTo(x,y) 定义线条结束坐标。绘制线条我们必须使用到 “ink” 的方法，就像stroke()。 1234567&lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(200,100); ctx.stroke();&lt;/script&gt; 定义开始坐标(0,0), 和结束坐标 (200,100). 然后使用 stroke() 方法来绘制线条。 Canvas - 文本 使用 canvas 绘制文本，重要的属性和方法如下：font - 定义字体。fillText(text,x,y) - 在 canvas 上绘制实心的文本。strokeText(text,x,y) - 在 canvas 上绘制空心的文本。使用 fillText(): 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.font=&quot;30px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,10,50); 使用 “Arial” 字体在画布上绘制一个高 30px 的文字（实心）。 Canvas - 渐变 渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。以下有两种不同的方式来设置Canvas渐变：createLinearGradient(x,y,x1,y1) - 创建线条渐变。createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。 1234567891011var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;); // Create gradientvar grd=ctx.createLinearGradient(0,0,200,0);grd.addColorStop(0,&quot;red&quot;);grd.addColorStop(1,&quot;white&quot;); // Fill with gradientctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 创建了一个线性渐变，使用渐变填充矩形。 Canvas - 图像 把一幅图像放置到画布上, 使用 drawImage(image,x,y) 方法。 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;scream&quot;);ctx.drawImage(img,10,10); 把一幅图像放置到了画布上。 (5)SVG绘图SVG 与 Canvas两者间的区别：SVG是指可伸缩的矢量图形，是一种使用 XML 描述 2D 图形的语言。Canvas 通过 JavaScript 来绘制 2D 图形。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 (6)地理定位HTML5 Geolocation（地理定位）用于定位用户的位置。 12345window.navigator.geolocation &#123; getCurrentPosition: fn 用于获取当前的位置数据 watchPosition: fn 监视用户位置的改变 clearWatch: fn 清除定位监视&#125; 获取用户定位信息： 1234567891011121314151617navigator.geolocation.getCurrentPosition( function(pos)&#123; console.log(&apos;用户定位数据获取成功&apos;) //console.log(arguments); console.log(&apos;定位时间：&apos;,pos.timestamp) console.log(&apos;经度：&apos;,pos.coords.longitude) console.log(&apos;纬度：&apos;,pos.coords.latitude) console.log(&apos;海拔：&apos;,pos.coords.altitude) console.log(&apos;速度：&apos;,pos.coords.speed)&#125;, //定位成功的回调function(err)&#123; console.log(&apos;用户定位数据获取失败&apos;) //console.log(arguments);&#125; //定位失败的回调) (7)拖放API拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。拖放的源对象(可能发生移动的)可以触发的事件——3个：dragstart：拖动开始drag：拖动中dragend：拖动结束整个拖动过程的组成： dragstart1 + dragn + dragend1拖放的目标对象(不会发生移动)可以触发的事件——4个：dragenter：拖动着进入dragover：拖动着悬停dragleave：拖动着离开drop：释放整个拖动过程的组成1： dragenter1 + dragovern + dragleave1整个拖动过程的组成2： dragenter1 + dragovern + drop*1 dataTransfer：用于数据传递的“拖拉机”对象； 在拖动源对象事件中使用e.dataTransfer属性保存数据：e.dataTransfer.setData( k, v ) 在拖动目标对象事件中使用e.dataTransfer属性读取数据：var value = e.dataTransfer.getData( k ) (8)Web Worker当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。首先检测浏览器是否支持 Web Worker. 123456if(typeof(Worker)!==&quot;undefined&quot;)&#123; // 是的! Web worker 支持! // 一些代码..... &#125;else&#123; // //抱歉! Web Worker 不支持 &#125; 下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码 1234if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; 然后我们就可以从 web worker 发送和接收消息了。向 web worker 添加一个 “onmessage” 事件监听器： 123w.onmessage=function(event)&#123;document.getElementById(&quot;result&quot;).innerHTML=event.data;&#125;; 当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。如需终止 web worker，并释放浏览器/计算机资源，使用 terminate() 方法。 完整的 Web Worker 实例代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Count numbers: &lt;output id=&quot;result&quot;&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick=&quot;startWorker()&quot;&gt;Start Worker&lt;/button&gt; &lt;button onclick=&quot;stopWorker()&quot;&gt;Stop Worker&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;script&gt;var w;function startWorker()&#123;if(typeof(Worker)!==&quot;undefined&quot;)&#123; if(typeof(w)==&quot;undefined&quot;) &#123; w=new Worker(&quot;demo_workers.js&quot;); &#125; w.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;;&#125;else&#123;document.getElementById(&quot;result&quot;).innerHTML=&quot;Sorry, your browser does not support Web Workers...&quot;;&#125;&#125;function stopWorker()&#123; w.terminate();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建的计数脚本，该脚本存储于 “demo_workers.js” 文件中。 12345678910var i=0; function timedCount() &#123; i=i+1; postMessage(i); setTimeout(&quot;timedCount()&quot;,500); &#125; timedCount(); (9)Web Storage使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。 客户端存储数据的两个对象为： localStorage - 没有时间限制的数据存储。 sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。 在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage： 123456789if(typeof(Storage)!==&quot;undefined&quot;) &#123; // 是的! 支持 localStorage sessionStorage 对象! // 一些代码..... &#125; else &#123; // 抱歉! 不支持 web 存储。 &#125; 不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); (10)WebSocketWebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;W3Cschool教程(w3cschool.cn)&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端书籍推荐]]></title>
    <url>%2F2019%2F01%2F15%2Fweb-book%2F</url>
    <content type="text"><![CDATA[JavaScript《JavaScript高级程序设计》入门级 推荐语： 详尽地解读了JS这门语言的各个组成部分，透彻地剖析了JS所涉及的编程思想，深入浅出地演示了丰富的JS应用实例…读完这本书你不一定就能成为前端大牛，但如果你真的能把这本书读懂，吃透，那么你离JS高手肯定不远啦！ 《编写可维护的JavaScript》入门级 推荐语： 乌龟书，很薄，但从工程实践的角度谈了常见的坑，其中的工作习惯值得coder们学习 《Javascript语言精粹》 蝴蝶书 推荐语： 集 JS 之精华，弃其糟粕，人手一本，前端必备 《锋利的jQuery》 入门级 推荐语： 前后台通用快速使用jQuery，必备良书。 《JavaScript DOM 编程艺术（第二版）》入门级 推荐语： 这本书的讲解方式非常亲切，人情味十足，初学者的福音。看完也能看看蝴蝶书。 《学习 JavaScript 数据结构与算法》入门级 推荐语： 很薄的一本书，很详细的讲解了使用js实现常用的数据结构和算法，对于更高效的使用js很有帮助。 《JavaScript 权威指南》 进阶级 推荐语： 这本书，我是十分推荐新手用作进阶阅读的。对于 JavaScript 新手入门来说，其实看什么书不重要，重要的是要能引起你兴趣使得你愿意动动手做做项目。在动手做过几个项目，对了 JavaScript 有了感性认识之后，你可能就会想要学习一些进阶内容，这时候《JavaScript 权威指南》就会成为最佳的选择。Ta的价值就在于，给予你工具的同时也通过示例告诉你什么情况下应该如何使用工具。 《JavaScript忍者秘籍》 进阶级 推荐语： 这本书是jQuery库创始人编写的一本深入剖析JavaScript语言的书 对JavaScript语言的重要部分（函数、闭包和原型）进行深入、全面的介绍，以及讲述跨浏览器代码如何编写 《高性能 JavaScript》进阶级 推荐语： 各种手段优化javascript 《ECMAScript 6 标准入门》进阶级 推荐语： 刘传宗：ES6让JavaScript如虎添翼，编程体验更佳，阮一峰前辈的力作 《Build Your Own AngularJS》进阶级 推荐语： 手把手教你撸出个angularjs框架，详细剖析原理和实现 《Effective JavaScript:编写高质量JavaScript代码的68个有效方法》进阶级 推荐语： 细说了编程中容易忽略的细枝末节！ 《你不知道的 JavaScript（上）》 进阶级 推荐语： 肯定没入门级的书让你成长的那么快，但是两本书（上册+下册）能让你更深入的理解 JS 机制，对项目有个良好的把控，推荐入门后的人看。详细的讲述了this，作用域，闭包，原型链等等，把js中比较难理解的部分用例子和通俗的语言讲解出来。 《单页Web应用：JavaScript 从前端到后端》进阶级 推荐语： 通过这本书的指引了解前后端如何一起构建一个单页应用，对前端来说，也能了解一些前端以外的东西 HTML5 &amp; CSS 《HTML5 与 CSS3 基础教程（第八版）》入门级 推荐语： 就是这本书把我带入前端的，非常适合初学前端的人看，浅显易懂，有配套代码！ 《深入浅出 HTML 与 CSS》入门级 推荐语： 纯小白的我第一次买的。懂了挺多。 《CSS揭秘》进阶级 推荐语： 这本书讲了很多CSS的技巧，看完之后你会拍着脑袋说原来CSS还有这么多你不知道的东西。 《HTML5 权威指南》进阶级推荐语： 系统、全面，没有高深的用法，比较简单，如果对应用要求一般，这本书的知识完全能够应付过来，辅佐以js语言精粹，完全足够 《CSS 权威指南》进阶级 推荐语： 本书适合自学过 CSS 的人但希望全面了解 CSS 的人阅读。由浅入深，全面易懂，不愧为权威指南。虽然内容有点儿老，但依然能够满足学习的需求。 综合类 《精通正则表达式》进阶级 推荐语： 全端通用技能必须get，看完后会感觉技能绝对上一个层次。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>前端书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
</search>
